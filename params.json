{"name":"Firebase Android Codelab","tagline":"","body":"#Building a chat application for Android\r\n\r\n| **Summary** | In this codelab, you'll learn how to build a chat application for Android using Firebase. |\r\n| :--------------: | :--------------------------------------------------------------------------------------------: |\r\n| **URL** | https://github.com/rohanraarora/Firebase-Codelab |\r\n| **Category** | Firebase |\r\n| **Feedback Link** | You can provide feedback on the content bundle and codelab here. |\r\n\r\n##Content\r\n* Overview\r\n* What you’ll learn\r\n* What you’ll need\r\n* Create a Firebase application\r\n* Create a project in Android Studio\r\n* Connect the Android project to Firebase\r\n* Allow the user to send a message\r\n* Show the (existing and new) messages\r\n* Enable login\r\n* Wrap-up\r\n* What we've covered\r\n* Next Steps\r\n* Learn More\r\n\r\n### Overview\r\nIn this codelab you’ll build a chat application for Android using Firebase and Android Studio.  \r\nWe’ll allow users to log in with an email/password combination.\r\n\r\n###What you’ll learn\r\n* Interacting with a Firebase Database from an Android application.  \r\n* Using Firebase Authentication in an Android application to authenticate users.\r\n\r\n###What you’ll need\r\n* [Android Studio](https://developer.android.com/sdk/installing/studio.html) version 1.0+\r\n* A test device or emulator with Android 4.1+\r\n* The device must have internet access to access the Firebase servers\r\n* While we'll show you what to do in Android Studio, this codelab does not try to explain how Android works.\r\n\r\n###Create a Firebase application\r\nDuration: 0:10\r\n\r\nThe first step is to create a Firebase application. This will be the server-side component that our Android application talks to.\r\n1.\tGo to the [Firebase](https://www.firebase.com/) web site  \r\n2.\tLogin or sign up  \r\n3.\tManage the app that was automatically created for you    \r\nThis app is on Firebase's free hacker plan. This plan is great for when you're developing your app on Firebase.  \r\n4.\tAny data that our Android application writes, will be visible in the Data tab  \r\n5.\tIn the Login & Auth tab, enable Email & Password authentication  \r\n\r\n###Create a project in Android Studio\r\nDuration: 0:10  \r\n\r\nIn this step we’ll create a project in Android Studio.  \r\n1.\tStart Android Studio and Start a new Android Studio project  \r\n2.\tYou can name the project anything you want. But in the code below, we’ve named it Nanochat   \r\n3.\tSet the minimum SDK to 15 (ICS) or higher. We've left it on 19 (KitKat) here.  \r\n4.\tStart with a Blank Activity  \r\n5.\tWe’ll leave all the defaults for this activity  \r\n6.\tIf the project outline is not visible on the left, click the 1:Project label  \r\n7.\tOpen up the main activity, which can be found in app/res/layout/activity_main.xml. In this file the root element will be a RelativeLayout and in there will be a TextView. We won’t be using the TextView, so delete it (or leave it and put a welcome message in it).\r\n \r\nWe now have a blank project in Android Studio. Let’s wire our app up to Firebase!\r\n\r\n###Connect the Android project to Firebase\r\nDuration: 0:15\r\n\r\nBefore we can start writing code that interacts with our Firebase database, we’ll need to make Android Studio aware that we’ll be using Firebase. We need to do this in two places: in the gradle build script and in our AndroidManifest.xml.\r\n\r\n* open Gradle Scripts > build.gradle (Module: app)  \r\nThis file contains the steps that Android Studio uses to build our app. We'll add a reference to Firebase to it, so we can start using it.\r\n\r\n* add the following line to the dependencies object at the bottom:  \r\n```  \r\n    compile 'com.firebase:firebase-client-android:2.3.0+'\r\n```\r\n  \r\n* add the following to the bottom of the android object  \r\n```  \r\n    packagingOptions {  \r\n        exclude 'META-INF/LICENSE'  \r\n        exclude 'META-INF/LICENSE-FIREBASE.txt'  \r\n        exclude 'META-INF/NOTICE'  \r\n    }  \r\n```\r\n  \r\n* at this stage you’ll probably need to synchronize the project with the gradle files again, so Tools > Android > Sync Project with Gradle Files. Android Studio will parse the gradle files and pick up our changes.\r\n\r\n* since Firebase is a hosted service, our app will need to be able to access the internet.\r\n\r\n* open app > manifests > AndroidManifest.xml\r\n\r\n* add this line inside the manifest element  \r\n```\r\n    <uses-permission android:name=\"android.permission.INTERNET\" />  \r\n```\r\n\r\n* In this step we’ll also  set up the initial connection between our code and its Firebase backend.\r\n\r\n* open MainActivity.java and add this code to the end of the onCreate method:\r\n```java\r\n    Firebase.setAndroidContext(this);\r\n```\r\n  This code allows the Firebase client to keep its context.\r\n* Import Firebase at the top of your MainActivity by adding the following line:\r\n```java\r\n    import com.firebase.client.Firebase;\r\n```\r\n\r\n* If Android Studio is having trouble finding the Firebase class, be sure that you’ve added the line to your gradle file and have synchronized the build file with the project.\r\n\r\n* We also want to create a connection to our database. We’ll keep this connection in a member field:  \r\n```java  \r\n    private Firebase mFirebaseRef;\r\n```  \r\n  that we initialize in onCreate:  \r\n```java  \r\n    mFirebaseRef = new Firebase(\"https://<your-app>.firebaseio.com\");\r\n```  \r\n  Be sure to replace `<your-app>` with the name of the Firebase app you created in the first section.\r\n \r\n\r\nThat’s all the setup that is required. Next up we’ll allow the user to enter a message in our app and send the message to Firebase.\r\n\r\n###Allow the user to send a message\r\nDuration: 0:20\r\n\r\nNow we can start sending data to Firebase! In this step we’ll allow the user to enter a message in a text box. When they then click the Send button, we will send the message to Firebase.\r\n \r\n\r\n* We’ll first add the necessary views to activity_main.xml:\r\n```\r\n    <LinearLayout\r\n        android:id=\"@+id/footer\"\r\n        android:layout_alignParentBottom=\"true\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:orientation=\"horizontal\">\r\n        <EditText\r\n            android:id=\"@+id/message_text\"\r\n            android:layout_width=\"0dp\"\r\n            android:layout_weight=\"1\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:singleLine=\"true\"\r\n            android:inputType=\"textShortMessage\" />\r\n        <Button\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:text=\"Send\" />\r\n    </LinearLayout>\r\n```  \r\n  Now we have an EditText, where the user can enter their chat message, and a Button that they can click to send the message.\r\n \r\n* In our MainActivity.java we’ll now add a member field for the EditText:\r\n```java\r\n    EditText mEditText;\r\n```  \r\n  and initialize it at the end of the onCreate method:\r\n```java\r\n    mMessageEditText = (EditText) this.findViewById(R.id.message_text);\r\n```\r\n\r\n* Next, we’ll add a method that grabs the text from the input and send it to our Firebase database:\r\n```java\r\n    public void onSendButtonClick(View v) {\r\n        String message = mMessageEdit.getText().toString();\r\n        Map<String,Object> values = new HashMap<>();\r\n        values.put(\"name\", \"puf\");\r\n        values.put(\"message\", message);\r\n        mFirebaseRef.push().setValue(values);\r\n        mMessageEdit.setText(\"\");\r\n    }\r\n```  \r\n  You will have to import the packages for some of these classes. Android Studio will tell you where to import them from.\r\n\r\n* Here we grab the message from the EditText, add it to a Map, and send it off to Firebase. We’ll look at a way to replace that Map with something more type-safe in the next section, but for now this will work.\r\nAlso note that we hard-coded our user name for the moment. We’ll use Firebase Authentication to make this dynamic  in the last section of this code lab.\r\n\r\n* Now we'll wire up the onSendButtonClick method to the button in main_acitivity.xml by adding this attribute to the button:\r\n```\r\n    android:onClick=\"onSendButtonClick\"\r\n```\r\n\r\n* If you now run the application in the emulator, you will see an input field with a Send button that sends the message to Firebase. Open the URL of your Firebase database, and you’ll see it light up green as you add new messages.\r\n\r\n* Open the Data tab in the Firebase Dashboard of your app. You’ll see it light up green as you add new messages. Admit it, this is pretty cool!\r\n\r\nNow that we can send messages to Firebase, it is time for the next step: making the messages show up in our Android app in realtime.\r\n\r\n\r\n###Show the (existing and new) messages\r\nDuration: 0:20\r\n\r\nA chat app that doesn’t show existing messages is not very useful. So in this step we’ll add a list of the existing messages to our Android app. At the end of this section we’ll have a fully functional chat app.\r\n\r\nLet's take this in chunks: first you'll build a new layout that we use to display each message, then you'll create a Java class to represent each message and finally we'll get the message from Firebase and put them into a ListView.\r\n\r\n* Each chat message has the same layout. So we’ll create a new layout XML file for the messages.\r\n\r\n* Create a new layout file message_layout.xml\r\n\r\n* in the layout XML, change the orientation of the LinearLayout to horizontal, so the we can have the user name on the left and the message on the right of it.\r\n```\r\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n        android:orientation=\"horizontal\" android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\">\r\n```\r\n\r\n* add two TextView controls to the layout: one for the username and one for the chat message:\r\n```\r\n    <TextView\r\n        android:id=\"@+id/username_text_view\"\r\n        android:text=\"Username\"\r\n        android:textStyle=\"bold\"\r\n        android:gravity=\"end\"\r\n        android:layout_width=\"0dp\"\r\n        android:layout_weight=\"3\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:padding=\"10dp\"/>\r\n\r\n    <TextView\r\n        android:id=\"@+id/message_text_view\"\r\n        android:text=\"Message\"\r\n        android:layout_width=\"0dp\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_weight=\"10\"\r\n        android:paddingLeft=\"0dp\"\r\n        android:paddingRight=\"10dp\"\r\n        android:paddingTop=\"10dp\"\r\n        android:paddingBottom=\"10dp\"/>\r\n```\r\n  Most of these attributes are just there to make the messages look reasonable. So feel free to use your own padding and layout attributes. Just be sure to use the same R.id fields in your code that you specify in the android:id attributes in the XML.\r\n \r\n* Now create a class ChatMessage.java that wraps the username and text message:\r\n```java\r\n      public class ChatMessage {\r\n          private String name;\r\n          private String message;\r\n\r\n          public ChatMessage() {\r\n            // necessary for Firebase's deserializer\r\n          }\r\n          public ChatMessage(String name, String message) {\r\n              this.name = name;\r\n              this.message = message;\r\n          }\r\n\r\n          public String getName() {\r\n              return name;\r\n          }\r\n\r\n          public String getMessage() {\r\n              return message;\r\n          }\r\n      }\r\n```\r\n  As you can see, this is plain-old Java object. But it’s a POJO with some special traits. First ChatMessage follows a JavaBean pattern for its property names. The getName method is a getter for a name property, while getMessage is a getter for a message property. And second, those property names correspond to the ones we’ve been using when we sent messages to Firebase in our onSendButtonClick() function.\r\n\r\n  If you end up making this ChatMessage an inner class of another class, you must make it static: public static class ChatMessage.\r\n \r\n* With the layout for the message specified and their structure defined in a class, now you need to make a space for them in the main_activity.xml\r\n\r\n* Add a ListView with android:id=\"@android:id/list\" above the LinearLayout:\r\n```\r\n    <ListView\r\n        android:id=\"@android:id/list\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\"\r\n        android:layout_above=\"@+id/footer\"/>\r\n```  \r\n  This is the container that all messages will be added to: one message_layout for each ChatMessage.  \r\nThe id value is very important here, since Android uses it to find the ListView. So make sure to enter it exactly as specified: @android:id/list.\r\n\r\n* Now download FirebaseListAdapter.java from <https://github.com/rohanraarora/Firebase-Codelab/blob/master/app/src/main/java/com/gdgnd/firebasecodelab/FirebaseListAdapter.java> and add it to your project. The FirebaseListAdapter class adapts a Firebase collection so that it becomes usable in an Android ListView. To add it to your app, add a new file to your application called FirebaseListAdapter and copy the Java code from the link above into that file. Don't forget to change the package name in the first line to match your project.\r\n\r\n* Make the MainActivity class descend from ListActivity. This is a built-in Android base-class. By deriving from this, our activity will automatically have access to the ListView we added to the layout:\r\n```java\r\n    public class MainActivity extends ListActivity {\r\n```\r\n\r\n* Now we'll make everything come together, by adding this to the onCreate method of our MainActivity:\r\n```java\r\n    mListAdapter = new FirebaseListAdapter<ChatMessage>(mFirebaseRef, ChatMessage.class,\r\n                                                        R.layout.message_layout, this) {\r\n        @Override\r\n        protected void populateView(View v, ChatMessage model) {\r\n            ((TextView)v.findViewById(R.id.username_text_view)).setText(model.getName());\r\n            ((TextView)v.findViewById(R.id.message_text_view)).setText(model.getMessage());\r\n        }\r\n    };\r\n    setListAdapter(mListAdapter);\r\n```\r\n  The FirebaseListAdapter maps the data from your Firebase database into the ListView that you added to the layout. It creates a new instance of your message_layout for each ChatMessage and calls the populateView method. You override this method and put the name and message in the correct subviews.\r\n \r\n* Don't worry, the hardest part is behind us now. All that is left in this step is some clean-up. But before that, run your app and see that it shows all existing messages. And if you send a new message, it shows up in the emulator and in your Firebase dashboard.\r\n\r\n* The cleanup is minor, but it's important to keep our code as readable as possible at all times. Remember that onSendButtonClick method that we wrote in step 5? That use of a Map looked a bit messy. Now that we have a ChatMessage class, we can make it much more readable:\r\n```java\r\n    public void onSendButtonClick(View v) {\r\n        String message = mMessageEdit.getText().toString();\r\n        mFirebaseRef.push().setValue(new ChatMessage(\"puf\", message));\r\n        mMessageEdit.setText(\"\");\r\n    }\r\n ```\r\n\r\nIn this section we made our app show the chat messages. It was a lot of work, but in the end you can see that the Java code is not that big, Thanks to firebase.\r\n\r\n###Enable login\r\nDuration: 0:15\r\nAs a final step, we're going to allow the users of our app to log in using email and password.\r\n \r\n\r\n* First add a button to the top right of activity_main.xml\r\n```\r\n    <Button\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"Login\"\r\n        android:id=\"@+id/login\"\r\n        android:layout_alignParentTop=\"true\"\r\n        android:layout_alignParentEnd=\"true\"\r\n        android:onClick=\"onLoginButtonClick\" />\r\n```  \r\n  Note that the button refers to an onLoginButtonClick method, which you'll create in a few minutes.\r\n\r\n* Now create a new layout called dialog_signin.xml, which we'll use to model the body of the sign-in dialog\r\n```\r\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n        android:orientation=\"vertical\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\">\r\n      <EditText\r\n          android:id=\"@+id/email\"\r\n          android:inputType=\"textEmailAddress\"\r\n          android:layout_width=\"match_parent\"\r\n          android:layout_height=\"wrap_content\"\r\n          android:layout_marginTop=\"16dp\"\r\n          android:layout_marginLeft=\"4dp\"\r\n          android:layout_marginRight=\"4dp\"\r\n          android:layout_marginBottom=\"4dp\"\r\n          android:hint=\"Email\" />\r\n      <EditText\r\n          android:id=\"@+id/password\"\r\n          android:inputType=\"textPassword\"\r\n          android:layout_width=\"match_parent\"\r\n          android:layout_height=\"wrap_content\"\r\n          android:layout_marginTop=\"4dp\"\r\n          android:layout_marginLeft=\"4dp\"\r\n          android:layout_marginRight=\"4dp\"\r\n          android:layout_marginBottom=\"16dp\"\r\n          android:hint=\"Password\"/>\r\n    </LinearLayout>\r\n```  \r\n  So we have two EditText controls under each other. The rest of the popup will be handled by a stock Android dialog.  Since your app will display the sign-in dialog as a popup, add the handling to MainActivity.java:\r\n```java\r\n    public void onLoginButtonClick(View v) {\r\n        AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n\r\n        builder.setMessage(\"Enter your email address and password\")\r\n               .setTitle(\"Log in\");\r\n\r\n        LayoutInflater inflater = this.getLayoutInflater();\r\n        builder.setView(inflater.inflate(R.layout.dialog_signin, null));\r\n\r\n        builder.setPositiveButton(\"OK\", new DialogInterface.OnClickListener() {\r\n            public void onClick(DialogInterface dialog, int id) {\r\n                AlertDialog dlg = (AlertDialog) dialog;\r\n                final String email = ((TextView)dlg.findViewById(R.id.email)).getText().toString();\r\n                final String password =((TextView)dlg.findViewById(R.id.password)).getText().toString();\r\n\r\n                // TODO: sign in to Firebase\r\n\r\n            }\r\n        });\r\n        builder.setNegativeButton(\"Cancel\", null);\r\n\r\n        AlertDialog dialog = builder.create();\r\n        dialog.show();\r\n    }\r\n```  \r\n  This method builds and show the dialog, with our two text boxes as the main body. When the user clicks OK, it extracts the email address and password from the text controls.\r\n \r\n* Now wire the values that we got from the dialog to the Firebase Authentication back-end. Replace the TODO with the following code:\r\n```java\r\n    mFirebaseRef.createUser(email, password, new Firebase.ResultHandler() {\r\n        @Override\r\n        public void onSuccess() {\r\n            mFirebaseRef.authWithPassword(email, password, null);\r\n        }\r\n        @Override\r\n        public void onError(FirebaseError firebaseError) {\r\n            mFirebaseRef.authWithPassword(email, password, null);\r\n        }\r\n    });\r\n```\r\n  In this code, we always try to register the user. If the user already registered that will result in onError, otherwise it will result on onSuccess.  \r\nEither way, we next call authWithPassword to authenticate the (pre-existing or just-created) user.\t\r\n\r\n* With the above we have the registration/login flow working. But we still need to listen to when Firebase Authentication tells us the user has been authenticated, so that we can store the username and use that in the chat message instead of the hard-coded value we have now.\r\n\r\n* Add a field to the class to hold the user name:\r\n```java\r\n    private String mUsername;\r\n```\r\n\r\n* Add the end of the onCreate method, add a callback method that listens for authentication state changes in Firebase:\r\n```java\r\n    mFirebaseRef.addAuthStateListener(new Firebase.AuthStateListener() {\r\n        @Override\r\n        public void onAuthStateChanged(AuthData authData) {\r\n            if(authData != null) {\r\n                mUsername = ((String)authData.getProviderData().get(\"email\"));\r\n                findViewById(R.id.login).setVisibility(View.INVISIBLE);\r\n            }\r\n            else {\r\n                mUsername = null;\r\n                findViewById(R.id.login).setVisibility(View.VISIBLE);\r\n            }\r\n        }\r\n    });\r\n```\r\n  Firebase calls our listener whenever the authentication state changes, so whenever the user logs in or out. When the user logs in, we store their email address in our field and hide the login button.\r\n\r\n  Firebase Authentication supports multiple authentication providers and each of them exposes a different set of data. For example, if we'd allow our users to authenticate with their existing Twitter account, we could identify them by their twitter handle.\r\n \r\n* Finally, replace the hard-coded username with the field we just populated:\r\n```java\r\n    mFirebaseRef.push().setValue(new ChatMessage(mUsername, message));\r\n```\r\n  We could definitely improve the layout of things. But this step has been long enough as it is. So let's wrap up with a few notes.\r\n\r\n* One thing you may note is that the user stays logged in, even when they restart the app. If instead you want to sign out the user, you can call:\r\n```java\r\n    mFirebaseRef.unauth();\r\n```\r\n  This will trigger the AuthStateListener we created before, which will clear the username field and re-enable the login button.\r\n\r\n* If you want to know which users logged in to your application, you can find them in the Login & Auth tab of your Firebase's dashboard.\r\n \r\nThis is also where you can configure the password reset emails that you can send to your users, in case they forgot their password.\r\n\r\n\r\n\r\n###Wrap-up\r\n\r\nCongratulations! You've just built a fully functional multi-user chat application that uses Firebase to store the data and authentication users.\r\n\r\nAs a reward for finishing the codelab you’ve earned a promo code! When you’re ready to put your Firebase app in production, you can use the promo code **androidcodelab49** for $49 off your first month of a paid Firebase plan. Just enter the code when you upgrade your Firebase. \r\n\r\n  \r\n\r\n###What we've covered\r\n✓\tInteracting with a Firebase Database from an Android application.  \r\n✓\tUsing Firebase Authentication in an Android application to authenticate users.\r\n\r\n###Next Steps\r\n* Add a log-out button to the app\r\n* Add a password-reset button to the login dialog\r\n* Allow the user to specify a nickname or use one of the Firebase's social authentication providers to look up their first name.\r\n* Get your app on the Play Store!\r\nLearn More\r\n* Learn all about using [Firebase with Android](https://www.firebase.com/docs/android/) by following the [Firebase for Android development guide](https://www.firebase.com/docs/android/guide/).\r\n* Study a more advanced sample application: [AndroidDrawing](https://github.com/firebase/AndroidDrawing)\r\n* Learn about [GeoFire](https://github.com/firebase/geofire-java) for Java, which allows you to add realtime location queries to your Android application","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}